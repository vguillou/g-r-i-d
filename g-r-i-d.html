<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<!--
A simple, configurable, responsive and adaptive grid layout.
The adaptive breakpoints are defined by the minimum width of the columns.
Gutter size, row height, grid items aspect-ratio and maximum width are
all easily manageable.
Note that it is achieved with a column direction flexbox that wraps.

Exemple: A grid with square 150px items, separated by 4px gutters. 

    <g-r-i-d min-column-width="150" gutter="4" row-height="100cw">
      <div class="item"></div>
      <div class="item"></div>
      <div class="item"></div>
      <div class="item"></div>
      <div class="item"></div>
    </g-r-i-d>

### Styling

The following custom properties and mixins are available for stylingt:

Custom property | Description | Default
----------------|-------------|----------
`--grid-layout` | Mixin applied to the grid layout (flexbox).<br/>Particularly interesting to control how the items are justified.<br/>(e.g.: `justify-content: center;`). | `{}`

@element g-r-i-d
@demo demo/index.html
-->
<dom-module id="g-r-i-d">
  <template>
    <style>
      :host {
        display: table;
        margin: 0 auto;
      }
      :host > #container {
        @apply(--layout-horizontal);
        @apply(--layout-wrap);
        @apply(--grid-layout);
        max-width: var(--grid-max-width);
        padding: 0;
      }
      :host > #container > ::content > * {
        @apply(--layout-flex-none);
        width: var(--grid-column-width);
        min-width: var(--grid-column-min-width);
        max-width: var(--grid-column-max-width);
        height: var(--grid-row-height);
        margin: var(--grid-gutter);
        box-sizing: border-box;
      }
      :host([columns="1"]) > #container {
        max-width: none;
        margin: 0 var(--grid-gutter);
      }
      :host([columns="1"]) > #container > ::content > * {
        width: calc(100% - 2 * var(--grid-gutter))  !important;
        max-width: none;
      }
      :host([columns="1"][responsive-when-narrow]) > #container > ::content > * {
        min-width: initial !important;
      }
      :host([no-outer-gutter]) > #container {
        margin: calc(var(--grid-gutter) * -1);
      }
    </style>
    <div id="container">
      <content></content>
    </div>
  </template>

  <script>
  (function() {
    'use strict';  
    Polymer({
      is: 'g-r-i-d',
      behaviors: [Polymer.IronResizableBehavior],
      properties: {
        /**
         * The effective number of columns of the grid.
         * Read-only.
         */
        columns: {
          type: Number,
          notify: true,
          reflectToAttribute: true,
          readOnly: true
        },
        /**
         * The minimun width of the columns in px.
         */
        minColumnWidth: {
          type: Number,
          value: 300,
          observer: 'refresh'
        },
        /**
         * The maximum width of the columns in px.
         */
        maxColumnWidth: {
          type: Number,
          value: undefined,
          observer: 'refresh'
        },
        /**
         * The height of the rows.
         * By default (or if `rowHeight` is `undefined`), each row
         * adapts it's height to it's content.
         * `rowHeight` can also be fixed with 2 units of measure:
         * pixels (px) and percentage of column width (cw).
         * Example :
         * <ul>
         * <li>undefined => Each row adapts it's height to it's content.</li>
         * <li>'150px' => All rows are 150px in height.</li>
         * <li>'100cw' => Row height is equal to column width: grid items are squared.</li>
         * <li>'50cw' => Row height is equal to half the column width:
         * grid items are rectangular with a 2/1 aspact-ratio.</li>
         * </ul>
         */
        rowHeight: {
          type: String,
          value: undefined,
          observer: 'refresh'
        },
        /**
         * The gutter width in px.
         */
        gutter: {
          type: Number,
          value: 4,
          observer: 'refresh'
        },
        /**
         * The maximum number of columns to display.
         */
        maxColumnNumber: {
          type: Number,
          value: undefined,
          observer: 'refresh'
        },
        /**
         * Removes the outer gutter.
         */
        noOuterGutter: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
          observer: 'refresh'
        },
        /**
         * Indicates if the unique column should become responsive when the grid itself
         * becomes narrower than `minColumnWidth`.
         * Effectively removes the horizontal scrollbar when the grid's width
         * is inferior to the specified `minColumnWidth`.
         */
        responsiveWhenNarrow: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
          observer: 'refresh'
        }
      },
      listeners: {
        'iron-resize': 'refresh'
      },

      /**
       * Triggers the refresh of all the mensuration of the grid.
       * Call if you modify the CSS width, padding or margin properties of the element.
       */
      refresh: function() {
        this._updateLayout(this.minColumnWidth, this.rowHeight, this.gutter, this.maxColumnWidth, this.maxColumnNumber, this.noOuterGutter, this.responsiveWhenNarrow);
      },

      ready: function (){
        Polymer.dom(this.$.container).observeNodes(function() {
          this.refresh();
        }.bind(this));
      },
      attached: function() {
        this.async(function() {
          this._updateLayout(this.minColumnWidth, this.rowHeight, this.gutter, this.maxColumnWidth, this.maxColumnNumber, this.noOuterGutter, this.responsiveWhenNarrow);
        }, 10);
      },
      _updateLayout: function(minColumnWidth, rowHeight, gutter, maxColumnWidth, maxColumnNumber, noOuterGutter, responsiveWhenNarrow) {
        // Measuring the space availlable
        var __sizingBase = this,
        __style = __sizingBase.currentStyle || window.getComputedStyle(__sizingBase),
        __w = __sizingBase.offsetWidth,
        __m = parseFloat(__style.marginLeft) + parseFloat(__style.marginRight),
        __p = parseFloat(__style.paddingLeft) + parseFloat(__style.paddingRight),
        __b = parseFloat(__style.borderLeftWidth) + parseFloat(__style.borderRightWidth);
        this._width = __w + __m - __p - __b;
        console.log(this._width, this.offsetWidth, this.$.container.offsetWidth, __b);
        // Calculate how much columns we can fit in
        var __colNumber = Math.floor(Math.max(1, (this._width + (noOuterGutter ? 2 * gutter : 0)) / (minColumnWidth + 2 * gutter || 1)));
        this._setColumns(maxColumnNumber > 0 ? Math.min(__colNumber, maxColumnNumber) : __colNumber);
        // Update computed CSS properties
        this._updateCustomStyles();
      },
      _updateCustomStyles: function() {
        var __maxWidth = 'none',
        __rowHeight = 'initial',
        __colWidth = (this._width - (2 * this.columns - (this.noOuterGutter ? 2 : 0)) * this.gutter) / this.columns,
        __colMaxWidth = this.maxColumnWidth > 0 ? this.maxColumnWidth : -1;

        if (this.maxColumnWidth > 0) {
          __maxWidth = (this.columns * this.maxColumnWidth) + (2 * this.columns * this.gutter) + 'px';
        }

        if (this.rowHeight) {
          // rowHeight in 'cw' (column width percentage)
          if (this.rowHeight.substr(this.rowHeight.length-2, this.rowHeight.length-1) === 'cw') {
            __rowHeight = this.rowHeight.substr(0, this.rowHeight.length-2);
            if (isNaN(__rowHeight)) {
              throw 'rowHeight "' + this.rowHeight + '" is invalid.';
            } else {
              __rowHeight = (Number(__rowHeight) / 100 * Math.min(__colWidth, this.maxColumnWidth > 0 ? this.maxColumnWidth : Number.MAX_VALUE)) + 'px';
            }
          } else {
            // rowHeight in any other unit
            __rowHeight = this.rowHeight;
          }
        }

        this.updateStyles({
          '--grid-column-width': __colWidth + 'px',
          '--grid-column-min-width': (this.columns < 2 ? this.minColumnWidth + 'px' : 'initial'),
          '--grid-column-max-width': (this.maxColumnWidth > 0 ? this.maxColumnWidth + 'px' : 'none'),
          '--grid-row-height': __rowHeight,
          '--grid-gutter': this.gutter + 'px',
          '--grid-max-width': __maxWidth
        });
      }
    });
  })();
  </script>
</dom-module>